"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const events_1 = __importDefault(require("events"));
const buffer_1 = require("buffer");
const mongodb_1 = require("mongodb");
const pify_1 = __importDefault(require("pify"));
const keyvMongoKeys = new Set(['url', 'collection', 'namespace', 'serialize', 'deserialize', 'uri', 'useGridFS', 'dialect']);
class KeyvMongo extends events_1.default {
    constructor(url, options) {
        super();
        this.ttlSupport = false;
        url = url ?? {};
        if (typeof url === 'string') {
            url = { url };
        }
        if (url.uri) {
            url = { url: url.uri, ...url };
        }
        this.opts = {
            url: 'mongodb://127.0.0.1:27017',
            collection: 'keyv',
            ...url,
            ...options,
        };
        const mongoOptions = Object.fromEntries(Object.entries(this.opts).filter(([k]) => !keyvMongoKeys.has(k)));
        this.opts = Object.fromEntries(Object.entries(this.opts).filter(([k]) => keyvMongoKeys.has(k)));
        // Implementation from sql by lukechilds,
        this.connect = new Promise(resolve => {
            mongodb_1.MongoClient.connect(this.opts.url, mongoOptions, (error, client) => {
                if (error) {
                    return this.emit('error', error);
                }
                const db = client.db(this.opts.db);
                if (this.opts.useGridFS) {
                    const bucket = new mongodb_1.GridFSBucket(db, {
                        readPreference: this.opts.readPreference,
                        bucketName: this.opts.collection,
                    });
                    const store = db.collection(`${this.opts.collection}.files`);
                    store.createIndex({
                        uploadDate: -1,
                    });
                    store.createIndex({
                        'metadata.expiresAt': 1,
                    });
                    store.createIndex({
                        'metadata.lastAccessed': 1,
                    });
                    for (const method of [
                        'updateOne',
                        'count',
                    ]) {
                        // @ts-expect-error - method needs to be a string
                        store[method] = (0, pify_1.default)(store[method].bind(store));
                    }
                    for (const method of [
                        'find',
                        'drop',
                    ]) {
                        // @ts-expect-error - method needs to be a string
                        bucket[method] = (0, pify_1.default)(bucket[method].bind(bucket));
                    }
                    resolve({ bucket, store, db });
                }
                else {
                    const store = db.collection(this.opts.collection);
                    store.createIndex({ key: 1 }, {
                        unique: true,
                        background: true,
                    });
                    store.createIndex({ expiresAt: 1 }, {
                        expireAfterSeconds: 0,
                        background: true,
                    });
                    for (const method of [
                        'updateOne',
                        'findOne',
                        'deleteOne',
                        'deleteMany',
                        'count',
                    ]) {
                        // @ts-expect-error - method needs to be a string
                        store[method] = (0, pify_1.default)(store[method].bind(store));
                    }
                    resolve({ store });
                }
            });
        });
    }
    async get(key) {
        if (this.opts.useGridFS) {
            const client = await this.connect;
            await client.store.updateOne({
                filename: key,
            }, {
                $set: {
                    'metadata.lastAccessed': new Date(),
                },
            });
            const stream = client.bucket.openDownloadStreamByName(key);
            return new Promise(resolve => {
                const resp = [];
                stream.on('error', () => {
                    resolve(undefined);
                });
                stream.on('end', () => {
                    const data = buffer_1.Buffer.concat(resp).toString('utf8');
                    resolve(data);
                });
                stream.on('data', chunk => {
                    resp.push(chunk);
                });
            });
        }
        const connect = await this.connect;
        const doc = await connect.store.findOne({ key: { $eq: key } });
        if (!doc) {
            return undefined;
        }
        return doc.value;
    }
    async getMany(keys) {
        if (this.opts.useGridFS) {
            const promises = [];
            for (const key of keys) {
                promises.push(this.get(key));
            }
            const values = await Promise.allSettled(promises);
            const data = [];
            for (const value of values) {
                // @ts-expect-error = value is PromiseFulfilledResult<Value>
                data.push(value.value);
            }
            return data;
        }
        const connect = await this.connect;
        // @ts-expect-error eslint-disable-next-line
        const values = await connect.store.s.db.collection(this.opts.collection)
            .find({ key: { $in: keys } })
            .project({ _id: 0, value: 1, key: 1 })
            .toArray();
        const results = [...keys];
        let i = 0;
        for (const key of keys) {
            const rowIndex = values.findIndex((row) => row.key === key);
            results[i] = rowIndex > -1 ? values[rowIndex].value : undefined;
            i++;
        }
        return results;
    }
    async set(key, value, ttl) {
        const expiresAt = typeof ttl === 'number' ? new Date(Date.now() + ttl) : null;
        if (this.opts.useGridFS) {
            const client = await this.connect;
            const stream = client.bucket.openUploadStream(key, {
                metadata: {
                    expiresAt,
                    lastAccessed: new Date(),
                },
            });
            return new Promise(resolve => {
                stream.on('finish', () => {
                    resolve(stream);
                });
                stream.end(value);
            });
        }
        const client = await this.connect;
        return client.store.updateOne({ key: { $eq: key } }, { $set: { key, value, expiresAt } }, { upsert: true });
    }
    async delete(key) {
        if (typeof key !== 'string') {
            return false;
        }
        const client = await this.connect;
        if (this.opts.useGridFS) {
            try {
                const connection = client.db;
                const bucket = new mongodb_1.GridFSBucket(connection, {
                    bucketName: this.opts.collection,
                });
                const files = await bucket.find({ filename: key }).toArray();
                await client.bucket.delete(files[0]._id);
                return true;
            }
            catch {
                return false;
            }
        }
        const object = await client.store.deleteOne({ key: { $eq: key } });
        return object.deletedCount > 0;
    }
    async deleteMany(keys) {
        const client = await this.connect;
        if (this.opts.useGridFS) {
            const connection = client.db;
            const bucket = new mongodb_1.GridFSBucket(connection, {
                bucketName: this.opts.collection,
            });
            const files = await bucket.find({ filename: { $in: keys } }).toArray();
            if (files.length === 0) {
                return false;
            }
            await Promise.all(files.map(async (file) => client.bucket.delete(file._id)));
            return true;
        }
        const object = await client.store.deleteMany({ key: { $in: keys } });
        return object.deletedCount > 0;
    }
    async clear() {
        const client = await this.connect;
        if (this.opts.useGridFS) {
            await client.bucket.drop();
        }
        await client.store.deleteMany({
            key: { $regex: this.namespace ? `^${this.namespace}:*` : '' },
        });
    }
    async clearExpired() {
        if (!this.opts.useGridFS) {
            return false;
        }
        return this.connect.then(async (client) => {
            const connection = client.db;
            const bucket = new mongodb_1.GridFSBucket(connection, {
                bucketName: this.opts.collection,
            });
            return bucket.find({
                'metadata.expiresAt': {
                    $lte: new Date(Date.now()),
                },
            }).toArray()
                .then(async (expiredFiles) => Promise.all(expiredFiles.map(async (file) => client.bucket.delete(file._id))).then(() => true));
        });
    }
    async clearUnusedFor(seconds) {
        if (!this.opts.useGridFS) {
            return false;
        }
        const client = await this.connect;
        const connection = client.db;
        const bucket = new mongodb_1.GridFSBucket(connection, {
            bucketName: this.opts.collection,
        });
        const lastAccessedFiles = await bucket.find({
            'metadata.lastAccessed': {
                $lte: new Date(Date.now() - (seconds * 1000)),
            },
        }).toArray();
        await Promise.all(lastAccessedFiles.map(async (file) => client.bucket.delete(file._id)));
        return true;
    }
    async *iterator(namespace) {
        const client = await this.connect;
        const iterator = client.store
            .find({
            key: new RegExp(`^${namespace ? namespace + ':' : '.*'}`),
        })
            .map((x) => [x.key, x.value]);
        yield* iterator;
    }
    async has(key) {
        const client = await this.connect;
        const filter = { [this.opts.useGridFS ? 'filename' : 'key']: { $eq: key } };
        const doc = await client.store.count(filter);
        return doc !== 0;
    }
}
module.exports = KeyvMongo;
//# sourceMappingURL=index.js.map